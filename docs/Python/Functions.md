---
layout: default
title: Функції
nav_order: 6
parent: Інформатика (Python)
description: "Курс Python на уроках Інформатики."
has_toc: false
---

# Функції

Як відомо, _підпрограмою_ називають відокремлену частину програми, що реалізує деякий алгоритм та може викликатись з інших частин програми. Раніше згадувалося, що підпрограми поділяють на процедури (що не повертають значень) та функції (які облислюють результат). У Python такого розрізнення немає, тому всі підпрограми називають _функціями_.

Визначаються вони ключовим словом `def` від англійського define — "визначити". Перелік даних, які може приймати функція, називається _параметрами_, а конкретні значення, надані під час виклику, є _аргументами_. Створимо простеньку функцію `my_func` без параметрів та викличемо її:

```python
def my_func():
    print("Привіт з функції!")
my_func()
```
За конвенцією назви змінних та функцій слід писати у [зміїному регістрі](https://uk.wikipedia.org/wiki/%D0%97%D0%BC%D1%96%D1%97%D0%BD%D0%B8%D0%B9_%D1%80%D0%B5%D0%B3%D1%96%D1%81%D1%82%D1%80), napryklad_os_tak. Щодо параметрів, у Пайтоні можна вказувати параметри "за замовчуванням". Це означає, що якщо у відповідність параметру не надали аргумент, буде використано вказане значення. Це дещо схоже на зручнішу альтернативу до перевантаження функцій у Java. Параметри за замовчуванням вказуються як значення після знаку "дорівнює".

```python
def square(number = 3):
    return number * number;
print( square(8) ) # 64
print( square() ) # 9, адже було використано 3 за замовчуванням
```
Також можна вказувати аргументи незалежно від їх порядку — для цього до кожного значення треба написати, до якого параметра слід його надати.

```python
def func(a, b = 2, c = 3):
    pass
func(1)                  # a = 1, b = 2, c = 3
func(10, 11)             # a = 10, b = 11, c = 3
func(10, c = 12)         # a = 10, b = 2, c = 12
func(10, c = 12, b = 11) # a = 10, b = 11, c = 12
func(10, 11, 12)         # a = 10, b = 11, c = 12
```
З попердніх розділів можливо було помітити, що там, де у Java були `...` — у Python `*`. _Аргументи змінної довжини_ (variable-length arguments) — особливий параметр, призначений для приймання довільної кількості аргументів. До нього записується залишок аргументів у вигляді кортежу.

```python
def print_all(*varargs):
    for arg in varargs:
        print(arg)
print_all('Тут', 'три', 'аргументи')
```

## Область видимості

_Облась видимості_, або область дії імен — це та частина програми, посилання імені на об'єкт у якій дійсне. Коли відбувається присвоєння значення до змінної, то значення зберігається в певній комірці пам'яті, яка має адресу (наприклад, 0x13fb07). У просторі даної функції або у глобальному просторі створюється посилання на цю комірку, яке і має ім'я.

![SchoolCoders](https://www.schoolcoders.com/img/programming-techniques/variables-and-expressions/variables.png)

У першому розділі розповідалось, що змінні створюються за співвикористанням, тобто якщо написати `var1 = var2 = 2`, на відміну від Java не створиться два значення "2", а просто буде два посилання на це значення.

![Alberto Oshiro](https://miro.medium.com/v2/resize:fit:600/format:webp/1*hmAUk_ZQ7ZFUNDCvn5uPKg.png)

Таким чином, коли відбувається вихід із функції, усі посилання, створені у ній, знищуюються. Відповідно, у Python змінні створюються у найбільш вужчій області видимості. Блоки не створюють окрему область, тому змінна, створена у циклі, залишається після нього доступною. Якщо ж створити змінну у функції, поза нею вона не буде доступною.

```python
x = 2
def func():
    x = 5 # Це нова внутрішня змінна x, незалежна від зовнішньої
    for i in range(3):
        pass
    # Після циклю i = 2 так і залишилось тут
# x = 2, адже функція не могла її змінити
```
Для того, щоб функція не створювала внутрішню змінну, а використовувала глобальну, таку змінну слід вказати `global` на початку функції. Також, так як функції можуть бути вкладеними, можна звертатись до змінної на одну область видимості вище, оголосивши змінну словом `nonlocal`.

```python
x = 2
def func1():
    x = 3
    def func2():
        nonlocal x # x посилатиметься на x у функції вище, x = 3
        x = 4
    func2()
    # тому тут тепер x = 4
func1()
# x все ще дорівнює тут 2
def func3():
    def func4():
        global x # x посилається на перший глобальний x = 2
        x = 5
    func4()
func3()
# тепер x = 5
```

## Лямбда-функції

У Python є можливість створювати функції без назв, які називають _анонімними функціями_. Вони є аналогічними "стрілочним функціям" у математиці: x ↦ M. У цій мові такі функції називають "лямбда-функціями" і зазвичай використовують для передачі невеликих алгоритмів в інші функції. Записують їх у такій формі:

```python
lambda <параметри>: <вираз>
```
Вираз обов'язково має повертати деяке значення. Наприклад, створимо лямбда-функцію суми `a` і `b` та запишемо цю функцію у змінну `suma`. Тепер можна викликати цю змінну з аргументами, адже вона зберігає функцію.

```python
suma = lambda a, b: a + b
print( suma(2, 3) ) # 5
```
Такі функції мають широкий спектр застосувань. Для прикладу наведу можливість зробити власний алгоритм сортування, нехай за довжиною рядків:

```python
arr = ['дім', 'автомобіль', "комп'ютер"]
arr.sort(key = lambda x: len(x))
```
